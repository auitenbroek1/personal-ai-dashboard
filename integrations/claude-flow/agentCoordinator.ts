import { PrismaClient } from '@prisma/client';\nimport { WebSocketService } from '../../dashboard/backend/src/services/websocketService';\nimport { MemoryBridge } from './memoryBridge';\n\ninterface SPARCAgent {\n  id: string;\n  name: string;\n  role: 'Strategist' | 'Planner' | 'Architect' | 'Researcher' | 'Coder';\n  status: 'idle' | 'active' | 'busy' | 'error' | 'offline';\n  currentTask?: string;\n  capabilities: string[];\n  config: Record<string, any>;\n}\n\nexport class AgentCoordinator {\n  private prisma: PrismaClient;\n  private wsService: WebSocketService;\n  private memoryBridge: MemoryBridge;\n  private registeredAgents: Map<string, SPARCAgent> = new Map();\n\n  constructor(prisma: PrismaClient, wsService: WebSocketService, memoryBridge: MemoryBridge) {\n    this.prisma = prisma;\n    this.wsService = wsService;\n    this.memoryBridge = memoryBridge;\n  }\n\n  // Register a SPARC agent\n  async registerAgent(agent: SPARCAgent): Promise<void> {\n    try {\n      // Store in database\n      await this.prisma.agent.upsert({\n        where: { id: agent.id },\n        update: {\n          name: agent.name,\n          type: agent.role.toLowerCase(),\n          status: agent.status,\n          config: {\n            role: agent.role,\n            capabilities: agent.capabilities,\n            ...agent.config\n          },\n          lastActive: new Date()\n        },\n        create: {\n          id: agent.id,\n          name: agent.name,\n          type: agent.role.toLowerCase(),\n          status: agent.status,\n          config: {\n            role: agent.role,\n            capabilities: agent.capabilities,\n            ...agent.config\n          }\n        }\n      });\n\n      // Update local registry\n      this.registeredAgents.set(agent.id, agent);\n\n      // Broadcast agent registration\n      this.wsService.broadcastAgentUpdate({\n        type: 'sparc_agent_registered',\n        agent: {\n          id: agent.id,\n          name: agent.name,\n          type: agent.role.toLowerCase(),\n          status: agent.status,\n          framework: 'SPARC'\n        }\n      });\n\n      // Update memory with agent registration\n      await this.updateAgentMemory(agent);\n\n      console.log(`✅ SPARC Agent registered: ${agent.name} (${agent.role})`);\n    } catch (error) {\n      console.error(`❌ Error registering SPARC agent ${agent.name}:`, error);\n    }\n  }\n\n  // Assign task to agent\n  async assignTask(agentId: string, task: {\n    title: string;\n    description: string;\n    priority: 'low' | 'medium' | 'high' | 'urgent';\n    metadata?: Record<string, any>;\n  }): Promise<string | null> {\n    try {\n      const agent = this.registeredAgents.get(agentId);\n      if (!agent) {\n        throw new Error(`Agent ${agentId} not found`);\n      }\n\n      // Create task in database\n      const dbTask = await this.prisma.task.create({\n        data: {\n          agentId,\n          title: task.title,\n          description: task.description,\n          priority: task.priority,\n          status: 'pending',\n          result: task.metadata || {}\n        }\n      });\n\n      // Update agent status\n      await this.updateAgentStatus(agentId, 'busy', dbTask.id);\n\n      // Broadcast task assignment\n      this.wsService.broadcastTaskUpdate({\n        type: 'task_assigned_to_sparc_agent',\n        task: dbTask,\n        agent: agent\n      });\n\n      console.log(`✅ Task assigned to SPARC agent ${agent.name}: ${task.title}`);\n      return dbTask.id;\n    } catch (error) {\n      console.error(`❌ Error assigning task to agent ${agentId}:`, error);\n      return null;\n    }\n  }\n\n  // Update agent status\n  async updateAgentStatus(agentId: string, status: string, currentTask?: string): Promise<void> {\n    try {\n      // Update database\n      await this.prisma.agent.update({\n        where: { id: agentId },\n        data: {\n          status,\n          lastActive: new Date(),\n          config: {\n            ...(await this.prisma.agent.findUnique({ where: { id: agentId } }))?.config,\n            currentTask\n          }\n        }\n      });\n\n      // Update local registry\n      const agent = this.registeredAgents.get(agentId);\n      if (agent) {\n        agent.status = status as any;\n        agent.currentTask = currentTask;\n      }\n\n      // Broadcast status update\n      this.wsService.broadcastAgentUpdate({\n        type: 'sparc_agent_status_updated',\n        agentId,\n        status,\n        currentTask\n      });\n    } catch (error) {\n      console.error(`❌ Error updating agent status for ${agentId}:`, error);\n    }\n  }\n\n  // Complete task\n  async completeTask(taskId: string, result: any): Promise<void> {\n    try {\n      const task = await this.prisma.task.update({\n        where: { id: taskId },\n        data: {\n          status: 'completed',\n          completedAt: new Date(),\n          result\n        },\n        include: { agent: true }\n      });\n\n      // Update agent status back to idle\n      await this.updateAgentStatus(task.agentId, 'idle');\n\n      // Broadcast task completion\n      this.wsService.broadcastTaskUpdate({\n        type: 'sparc_task_completed',\n        task,\n        result\n      });\n\n      console.log(`✅ SPARC task completed: ${task.title}`);\n    } catch (error) {\n      console.error(`❌ Error completing task ${taskId}:`, error);\n    }\n  }\n\n  // Get agent coordination status\n  async getCoordinationStatus(): Promise<{\n    totalAgents: number;\n    activeAgents: number;\n    pendingTasks: number;\n    completedTasks: number;\n    agentsByRole: Record<string, number>;\n  }> {\n    const [totalAgents, activeAgents, pendingTasks, completedTasks] = await Promise.all([\n      this.prisma.agent.count(),\n      this.prisma.agent.count({ where: { status: { in: ['active', 'busy'] } } }),\n      this.prisma.task.count({ where: { status: { in: ['pending', 'in_progress'] } } }),\n      this.prisma.task.count({ where: { status: 'completed' } })\n    ]);\n\n    const agents = await this.prisma.agent.findMany();\n    const agentsByRole = agents.reduce((acc, agent) => {\n      const role = agent.config?.role || agent.type;\n      acc[role] = (acc[role] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    return {\n      totalAgents,\n      activeAgents,\n      pendingTasks,\n      completedTasks,\n      agentsByRole\n    };\n  }\n\n  // SPARC workflow coordination\n  async coordinateSPARCWorkflow(request: {\n    type: 'research' | 'development' | 'analysis' | 'planning';\n    description: string;\n    priority: 'low' | 'medium' | 'high' | 'urgent';\n    requiredRoles: string[];\n  }): Promise<string[]> {\n    const taskIds: string[] = [];\n\n    try {\n      // Assign tasks based on SPARC methodology\n      for (const role of request.requiredRoles) {\n        const availableAgents = Array.from(this.registeredAgents.values())\n          .filter(agent => agent.role.toLowerCase() === role.toLowerCase() && agent.status === 'idle');\n\n        if (availableAgents.length > 0) {\n          const agent = availableAgents[0]; // Simple assignment, could be enhanced with load balancing\n          \n          const taskId = await this.assignTask(agent.id, {\n            title: `${role} Task: ${request.description}`,\n            description: `SPARC workflow task for ${role} agent: ${request.description}`,\n            priority: request.priority,\n            metadata: {\n              workflowType: request.type,\n              sparcRole: role,\n              coordinatedWorkflow: true\n            }\n          });\n\n          if (taskId) {\n            taskIds.push(taskId);\n          }\n        }\n      }\n\n      console.log(`✅ SPARC workflow coordinated: ${taskIds.length} tasks assigned`);\n      return taskIds;\n    } catch (error) {\n      console.error('❌ Error coordinating SPARC workflow:', error);\n      return taskIds;\n    }\n  }\n\n  private async updateAgentMemory(agent: SPARCAgent): Promise<void> {\n    try {\n      await this.prisma.memoryEntry.upsert({\n        where: { key: `sparc_agent_${agent.id}` },\n        update: {\n          value: {\n            id: agent.id,\n            name: agent.name,\n            role: agent.role,\n            status: agent.status,\n            capabilities: agent.capabilities,\n            lastRegistered: new Date().toISOString()\n          },\n          updatedAt: new Date()\n        },\n        create: {\n          key: `sparc_agent_${agent.id}`,\n          value: {\n            id: agent.id,\n            name: agent.name,\n            role: agent.role,\n            status: agent.status,\n            capabilities: agent.capabilities,\n            registered: new Date().toISOString()\n          },\n          type: 'sparc_agent',\n          namespace: 'agents'\n        }\n      });\n    } catch (error) {\n      console.error('❌ Error updating agent memory:', error);\n    }\n  }\n}"}