import { PrismaClient } from '@prisma/client';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport class MemoryService {\n  private prisma: PrismaClient;\n  private memoryPath: string;\n\n  constructor(prisma: PrismaClient, memoryPath?: string) {\n    this.prisma = prisma;\n    this.memoryPath = memoryPath || path.join(process.cwd(), '../memory/data/entries.json');\n  }\n\n  // Store memory entry\n  async store(key: string, value: any, type: string = 'general', namespace: string = 'default'): Promise<void> {\n    try {\n      await this.prisma.memoryEntry.upsert({\n        where: { key },\n        update: {\n          value,\n          type,\n          namespace,\n          updatedAt: new Date()\n        },\n        create: {\n          key,\n          value,\n          type,\n          namespace\n        }\n      });\n\n      // Also update the file-based memory for compatibility\n      await this.syncToFile();\n    } catch (error) {\n      console.error(`❌ Error storing memory entry ${key}:`, error);\n    }\n  }\n\n  // Retrieve memory entry\n  async retrieve(key: string): Promise<any | null> {\n    try {\n      const entry = await this.prisma.memoryEntry.findUnique({\n        where: { key }\n      });\n      return entry?.value || null;\n    } catch (error) {\n      console.error(`❌ Error retrieving memory entry ${key}:`, error);\n      return null;\n    }\n  }\n\n  // Search memory entries\n  async search(query: {\n    type?: string;\n    namespace?: string;\n    keyPattern?: string;\n    limit?: number;\n  }): Promise<Array<{ key: string; value: any; type: string; namespace: string }>> {\n    try {\n      const where: any = {};\n      \n      if (query.type) where.type = query.type;\n      if (query.namespace) where.namespace = query.namespace;\n      if (query.keyPattern) {\n        where.key = {\n          contains: query.keyPattern\n        };\n      }\n\n      const entries = await this.prisma.memoryEntry.findMany({\n        where,\n        take: query.limit || 100,\n        orderBy: { updatedAt: 'desc' }\n      });\n\n      return entries.map(entry => ({\n        key: entry.key,\n        value: entry.value,\n        type: entry.type,\n        namespace: entry.namespace\n      }));\n    } catch (error) {\n      console.error('❌ Error searching memory entries:', error);\n      return [];\n    }\n  }\n\n  // Delete memory entry\n  async delete(key: string): Promise<boolean> {\n    try {\n      await this.prisma.memoryEntry.delete({\n        where: { key }\n      });\n      \n      await this.syncToFile();\n      return true;\n    } catch (error) {\n      console.error(`❌ Error deleting memory entry ${key}:`, error);\n      return false;\n    }\n  }\n\n  // Get memory statistics\n  async getStats(): Promise<{\n    totalEntries: number;\n    entriesByType: Record<string, number>;\n    entriesByNamespace: Record<string, number>;\n    lastUpdate: Date;\n  }> {\n    try {\n      const [totalEntries, entries, lastEntry] = await Promise.all([\n        this.prisma.memoryEntry.count(),\n        this.prisma.memoryEntry.findMany({\n          select: { type: true, namespace: true }\n        }),\n        this.prisma.memoryEntry.findFirst({\n          orderBy: { updatedAt: 'desc' },\n          select: { updatedAt: true }\n        })\n      ]);\n\n      const entriesByType = entries.reduce((acc, entry) => {\n        acc[entry.type] = (acc[entry.type] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      const entriesByNamespace = entries.reduce((acc, entry) => {\n        acc[entry.namespace] = (acc[entry.namespace] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      return {\n        totalEntries,\n        entriesByType,\n        entriesByNamespace,\n        lastUpdate: lastEntry?.updatedAt || new Date()\n      };\n    } catch (error) {\n      console.error('❌ Error getting memory stats:', error);\n      return {\n        totalEntries: 0,\n        entriesByType: {},\n        entriesByNamespace: {},\n        lastUpdate: new Date()\n      };\n    }\n  }\n\n  // Store dashboard state\n  async storeDashboardState(state: {\n    agents: any[];\n    tasks: any[];\n    metrics: any[];\n    alerts: any[];\n    timestamp: Date;\n  }): Promise<void> {\n    await this.store('dashboard_state', state, 'dashboard_state', 'system');\n  }\n\n  // Retrieve dashboard state\n  async retrieveDashboardState(): Promise<any | null> {\n    return await this.retrieve('dashboard_state');\n  }\n\n  // Store system configuration\n  async storeSystemConfig(config: Record<string, any>): Promise<void> {\n    await this.store('system_config', config, 'system_config', 'system');\n  }\n\n  // Retrieve system configuration\n  async retrieveSystemConfig(): Promise<Record<string, any> | null> {\n    return await this.retrieve('system_config');\n  }\n\n  // Sync database entries to file (for compatibility with existing Claude-Flow)\n  private async syncToFile(): Promise<void> {\n    try {\n      const entries = await this.prisma.memoryEntry.findMany();\n      \n      const fileData = {\n        entries: entries.map(entry => ({\n          id: entry.id,\n          key: entry.key,\n          value: entry.value,\n          type: entry.type,\n          namespace: entry.namespace,\n          created_at: entry.createdAt.toISOString(),\n          updated_at: entry.updatedAt.toISOString()\n        })),\n        metadata: {\n          version: '1.0.0',\n          lastUpdate: new Date().toISOString(),\n          totalEntries: entries.length,\n          syncedFromDashboard: true\n        }\n      };\n\n      await fs.writeFile(this.memoryPath, JSON.stringify(fileData, null, 2));\n    } catch (error) {\n      console.error('❌ Error syncing to file:', error);\n    }\n  }\n\n  // Load from file (for initial sync)\n  async loadFromFile(): Promise<void> {\n    try {\n      const data = await fs.readFile(this.memoryPath, 'utf-8');\n      const fileData = JSON.parse(data);\n\n      if (fileData.entries && Array.isArray(fileData.entries)) {\n        for (const entry of fileData.entries) {\n          await this.prisma.memoryEntry.upsert({\n            where: { key: entry.key },\n            update: {\n              value: entry.value,\n              type: entry.type,\n              namespace: entry.namespace,\n              updatedAt: new Date(entry.updated_at)\n            },\n            create: {\n              key: entry.key,\n              value: entry.value,\n              type: entry.type,\n              namespace: entry.namespace,\n              createdAt: new Date(entry.created_at),\n              updatedAt: new Date(entry.updated_at)\n            }\n          });\n        }\n        \n        console.log(`✅ Loaded ${fileData.entries.length} memory entries from file`);\n      }\n    } catch (error) {\n      console.warn('⚠️  Could not load memory from file (file may not exist yet):', error.message);\n    }\n  }\n}"}