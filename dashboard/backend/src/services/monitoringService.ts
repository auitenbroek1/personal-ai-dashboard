import { PrismaClient } from '@prisma/client';\nimport { WebSocketService } from './websocketService';\nimport * as cron from 'node-cron';\n\nexport class MonitoringService {\n  private prisma: PrismaClient;\n  private wsService: WebSocketService;\n  private isRunning: boolean = false;\n\n  constructor(prisma: PrismaClient, wsService: WebSocketService) {\n    this.prisma = prisma;\n    this.wsService = wsService;\n  }\n\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    console.log('🔍 Monitoring service started');\n\n    // Collect system metrics every 30 seconds\n    cron.schedule('*/30 * * * * *', () => {\n      this.collectSystemMetrics();\n    });\n\n    // Check agent health every minute\n    cron.schedule('0 * * * * *', () => {\n      this.checkAgentHealth();\n    });\n\n    // Clean up old metrics every hour\n    cron.schedule('0 0 * * * *', () => {\n      this.cleanupOldMetrics();\n    });\n  }\n\n  stop() {\n    this.isRunning = false;\n    console.log('🛑 Monitoring service stopped');\n  }\n\n  private async collectSystemMetrics() {\n    try {\n      // Collect basic system metrics\n      const metrics = [\n        {\n          metricType: 'active_agents',\n          value: await this.getActiveAgentsCount(),\n        },\n        {\n          metricType: 'completed_tasks',\n          value: await this.getCompletedTasksCount(),\n        },\n        {\n          metricType: 'connected_clients',\n          value: this.wsService.getConnectedClientsCount(),\n        },\n        {\n          metricType: 'memory_usage',\n          value: this.getMemoryUsage(),\n        },\n      ];\n\n      // Store metrics in database\n      for (const metric of metrics) {\n        await this.prisma.systemMetric.create({\n          data: {\n            metricType: metric.metricType,\n            value: metric.value,\n            metadata: {}\n          }\n        });\n      }\n\n      // Broadcast metrics update\n      this.wsService.broadcastMetricUpdate({\n        type: 'metrics_collected',\n        metrics\n      });\n    } catch (error) {\n      console.error('Error collecting system metrics:', error);\n    }\n  }\n\n  private async checkAgentHealth() {\n    try {\n      const agents = await this.prisma.agent.findMany();\n      \n      for (const agent of agents) {\n        const timeSinceLastActive = Date.now() - new Date(agent.lastActive).getTime();\n        const fiveMinutesInMs = 5 * 60 * 1000;\n        \n        // Mark agent as offline if inactive for more than 5 minutes\n        if (timeSinceLastActive > fiveMinutesInMs && agent.status !== 'offline') {\n          await this.prisma.agent.update({\n            where: { id: agent.id },\n            data: { status: 'offline' }\n          });\n          \n          // Broadcast agent status change\n          this.wsService.broadcastAgentUpdate({\n            type: 'agent_status_changed',\n            agent: { ...agent, status: 'offline' }\n          });\n          \n          // Create alert\n          await this.createAlert({\n            type: 'agent_failure',\n            severity: 'warning',\n            title: `Agent ${agent.name} went offline`,\n            description: `Agent ${agent.name} has been inactive for more than 5 minutes`\n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error checking agent health:', error);\n    }\n  }\n\n  private async cleanupOldMetrics() {\n    try {\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n      \n      await this.prisma.systemMetric.deleteMany({\n        where: {\n          timestamp: {\n            lt: thirtyDaysAgo\n          }\n        }\n      });\n      \n      console.log('✨ Old metrics cleaned up');\n    } catch (error) {\n      console.error('Error cleaning up old metrics:', error);\n    }\n  }\n\n  private async getActiveAgentsCount(): Promise<number> {\n    return await this.prisma.agent.count({\n      where: {\n        status: {\n          in: ['active', 'busy']\n        }\n      }\n    });\n  }\n\n  private async getCompletedTasksCount(): Promise<number> {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    return await this.prisma.task.count({\n      where: {\n        status: 'completed',\n        completedAt: {\n          gte: today\n        }\n      }\n    });\n  }\n\n  private getMemoryUsage(): number {\n    const memUsage = process.memoryUsage();\n    return Math.round(memUsage.heapUsed / 1024 / 1024); // MB\n  }\n\n  private async createAlert(alertData: {\n    type: string;\n    severity: string;\n    title: string;\n    description: string;\n  }) {\n    try {\n      const alert = await this.prisma.alert.create({\n        data: alertData\n      });\n      \n      // Broadcast alert\n      this.wsService.broadcastAlert({\n        type: 'new_alert',\n        alert\n      });\n      \n      return alert;\n    } catch (error) {\n      console.error('Error creating alert:', error);\n    }\n  }\n}"}